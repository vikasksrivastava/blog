#### Modules

> This file is based on the Youtube video `https://www.youtube.com/watch?v=AdIcYrz3AjU&t=1854s`

Below is a sample YANG file generated by the `ncs-make-package --service-skeleton template ospf_deploy` . We will use this for our learnign and understanding for the YANG file and so the same based on real life YANG file examples.

> Notes are added as comments in the file below

```shell

module ospf_deploy {
  namespace "http://com/example/ospf_deploy";
  prefix ospf_deploy;

  import ietf-inet-types {
    prefix inet;
  }
  import tailf-ncs {
    prefix ncs;
  }
  organisation "ACME Inc";
  revision 2007-01-02 {
    description "Second version v2";
  }
}
```


Note above that each module begins with the module declaration , the filename should equal the module name.Each module is uniqiely identified in the system with the `namespace`
`prefix` below is how the namespace will be refrenced in the file goign forward. Something like `ospf_deploy:` followed by something.


> Note that YANG is XML Definition langauage and maps one to one with XML.

The `import` and `include` add other modules to the YANG model.

Using the revision ifnormation in , when workign with NETCONF ,it will advertise the version wehich will make the managment device know waht s the device caapable of .

`import`  A yang imports is similar to including a Header file in a C Code.

`include` Include statement is used to pull  submodules into a main. A module doees not have to be contained within one file. You can decompose it for ease of maintenance design.

`submodules`

A submodule is a written in a separate `acme-system.yang` file and does not have a namespace of its own. (Notice the same in the picture below)

THe submodule is included in the parent module ,

so paremt module can refer --> to the submodule
but submodule cannot  refere to items in the parent module .

![](assets/markdown-img-paste-20180427203352491.png)



#### YANG Base Types

![](assets/markdown-img-paste-20180427203844448.png)




##### Typedef
Below is the a Typedef defined for `percent` . The leaf `completed` inherits the typedef `percent`.


```shell
typedef percent {
  type unit16 {
    range "0 .. 100"
  }
  description "Percentage";
}

leaf completed {
  type percent;
}
```

##### Type Restrictions

Notice below how Restrictions are applied on derived-int32 .

```shell
typedef my-base-int32-type {
  type int32 {
    range "1..4 | 10..20"  # 1 to 4 and 10 to 20
  }
}

typedef derived-int32 {
  type my-base-int32-type {
    range "11..max";   # Derived from the typedef above but is only limited to 11 to 20 .
  }
}

```

##### Union Statement

```shell
typedef threshold {
  type union {
    type uint16 {
      range "0 .. 100";
    }
    type enumeration {
      enum disabled {
        description "No threshold";
      }
    }
  }
}

```

`Youtube 12:33`

##### Common YANG types

Common Networking Data types are stores in `ietf-yang-types` (RFC 6021) like the following.
These can be added to the your YANG file using the following.

```shell
import `ietf-yang-types` {
  perfix yang
}

leaf remote-ip {
  type yang:ipv4-address {  # Here we refer the ietf yang type for IPv4 address.
    pattern "10\\.0\\.0\\.[0-9]+";
  }
```

![](assets/markdown-img-paste-20180427210037515.png)

##### Grouping Statement

Grouping can contain any YANG structure (leafs or containers etc) .
In this example we group

```shell
module ospf_deploy {
  namespace "http://com/example/ospf_deploy";
  prefix ospf_deploy;

  import "ietf-inet-types" {
    prefix inet;
  }

  grouping target {
    leaf address {
      type inet:ip-address;
      description "Target IP";
    }
    leaf port {
      type inet:port-number;
      description "Target port";
    }
  }

    container peer {
      container destination {
        uses target;
      }
    }

  }
```

Notice that when you view the actual output of the code above , it lists the container structure starting with `peer` , `destination` and then adds the `target ` group to it .

```sh
#pyang -f tree ospf_deploy.yang module: ospf_deploy
      +--rw peer
         +--rw destination
            +--rw address?   inet:ip-address
            +--rw port?      inet:port-number
```

#### Grouping Statement with Refine

So with `refine`  we further take the above example and refine the grouping with some contstraints or defaults. In the example below we set the default value to 80.

```sh
grouping target {
  leaf address {
    type inet:ip-address;
    description "Target IP";
  }
  leaf port {
    type inet:port-number;
    description "Target port";
  }
}

  container peer {
    container destination {
      uses target {
        refine port {
          default 80;
        }
      }
    }
  }
```

### YANG Data Definitions

#### Leaf Statement

A leaf is a single item and can have multiple attributes.

```sh
leaf host-name {
  type string;
  mandatory true;
  config true;

}
```

![](assets/markdown-img-paste-20180428012909221.png)


#### Container Statement

A container is used to organise the leafs in a structure. It does not have type of its own.

```sh
container system {
  containers services {
    container ssh {
      presence "Enables SSH"
      description "SSH Service Specific configuration"
    }
  }
}
```

#### Leaf-list Statement

Its is a list of items . Do not see this as an array .

```sh
leaf-list domains-search {
  type string;
  ordered-by user; # How the list is ordered.
  description "List of domain names to search";
}
```


#### List Statements

![](assets/markdown-img-paste-20180428013507879.png)

Think of Lists as a Table of Items , `key` is the key of the data table.

#### Attributes of list an leaf-lists

![](assets/markdown-img-paste-20180428013616564.png)


#### Keys

The key field is used to specific which row are we reffering to .

![](assets/markdown-img-paste-20180428013718752.png)


#### Multiple Keys

Notice in the example below we have the `key "ip prefix"` allowing us to select based on two keys , IP and Prefix.

![](assets/markdown-img-paste-20180428014213415.png)


### Leafref

A Leafref can refer to another leaf . So basically what it means is , the only calues can be selected are the values the Leafref is poiting to .

![](assets/markdown-img-paste-2018042801564567.png)


### Multiple Key Leafref

In the example below , a give set of IP and Port is to be selected from the client table.
Now selecting the Ip Address is easy , but there are duplicate IP Addresses .

Having the Xpath of `ip=current()`  helps us go back in the tree and ensure integrity by limiting the scope to the current v-ip in question .

![](assets/markdown-img-paste-2018042802003507.png)

#### Deref() XPATH Operator

Now looking at the example above of Leafref , if the number of keys increases (v-ip , v-port .... and v-stream) it will get convuluted in the nesting of the `current` pointer .

This is made easy by the `deref()` operator.

![](assets/markdown-img-paste-20180428020523200.png)

`http://www.yang-central.org/twiki/pub/Main/YangTools/pyang.1.html`

The deref function follows the reference defined by the first node in document order in the argument node-set, and returns the nodes it refers to.

If the first argument node is an instance-identifier, the function returns a node-set that contains the single node that the instance identifier refers to, if it exists. If no such node exists, an empty node-set is returned.

If the first argument node is a leafref, the function returns a node-set that contains the nodes that the leafref refers to.

If the first argument node is of any other type, an empty node-set is returned.

The following example shows how a leafref can be written with and without the deref function:

```sh
/* without deref */

leaf my-ip {
  type leafref {
    path "/server/ip";
  }
}
leaf my-port {
  type leafref {
    path "/server[ip = current()/../my-ip]/port";
  }
}

/* with deref */

leaf my-ip {
  type leafref {
    path "/server/ip";
  }
}
leaf my-port {
  type leafref {
    path "deref(../my-ip)/../port";
  }
}
```

.
.
.
.
.
.
.
.
.
.
.
.
.
----

**`optimized.l2vpn.yang`**
---

```shell
module l2vpn {
  namespace "http://com/example/l2vpn";
  prefix l2vpn;

  import ietf-inet-types {
    prefix inet;
  }
  import tailf-ncs {
    prefix ncs;
  }
  import tailf-common {
    prefix tailf;
  }

  import tailf-ned-cisco-ios {
    prefix ios;
  }
  import tailf-ned-cisco-ios-xr {
    prefix cisco-ios-xr;
  }

  augment "/ncs:services" {
    list l2vpn {
      key "name";
      unique "pw-id";
      uses ncs:service-data;
      ncs:servicepoint "l2vpn";
      leaf name {
        tailf:info "Service Instance Name";
        mandatory true;
        type string;
      }
      leaf pw-id {
        tailf:info "Unique Pseudowire ID";
        mandatory true;
        type uint32 {
          range "1..4294967295";
        }
      }
      list link {
        tailf:info "Attachment Circuits";
        min-elements 2;
        max-elements "2";
        key "device";
        leaf device {
          tailf:info "PE Router";
          mandatory true;
          type leafref {
            path "/ncs:devices/ncs:device/ncs:name";
          }
        }
        container ios {
          when "/ncs:devices/ncs:device[ncs:name=current()/../device]/ncs:device-type/ncs:cli/ncs:ned-id='ios-id:cisco-ios'" {
            tailf:dependency "../device";
            tailf:dependency "/ncs:devices/ncs:device/ncs:device-type";
          }
          leaf intf-number {
            tailf:info "GigabitEthernet Interface ID";
            mandatory true;
            type leafref {
              path "deref(../../device)/../ncs:config/ios:interface/ios:GigabitEthernet/ios:name";

            }
          }
        }
        container iosxr {
          when "/ncs:devices/ncs:device[ncs:name=current()/../device]/ncs:device-type/ncs:cli/ncs:ned-id='cisco-ios-xr-id:cisco-ios-xr'" {
            tailf:dependency "../device";
            tailf:dependency "/ncs:devices/ncs:device/ncs:device-type";
          }
          leaf intf-number {
            tailf:info "GigabitEthernet Interface ID";
            mandatory true;
            type leafref {
              path "deref(../../device)/../ncs:config/cisco-ios-xr:interface/cisco-ios-xr:GigabitEthernet/cisco-ios-xr:id";
            }
          }
        }
        leaf remote-ip {
          tailf:info "Loopback0 IP Address of Remote PE (10.0.0.X)";
          mandatory true;
          type inet:ipv4-address {
            pattern "10\\.0\\.0\\.[0-9]+";
          }
        }
      }
    }
  }
}
```





**`ospf_deploy.yang`**
---


```shell

module ospf_deploy {
  namespace "http://com/example/ospf_deploy";
  prefix ospf_deploy;

  import ietf-inet-types {
    prefix inet;
  }
  import tailf-ncs {
    prefix ncs;
  }

  list ospf_deploy {
    key name;

    uses ncs:service-data;
    ncs:servicepoint "ospf_deploy";

    leaf name {
      type string;
    }

    // may replace this with other ways of refering to the devices.
    leaf-list device {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:name";
      }
    }

    // replace with your own stuff here
    leaf dummy {
      type inet:ipv4-address;
    }
  }
}
```
